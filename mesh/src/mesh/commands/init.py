"""Interactive setup wizard for mesh network configuration."""

import platform
import shutil
import socket
from pathlib import Path

import typer
from rich.prompt import Confirm, Prompt

from mesh.core.config import save_headscale_server
from mesh.core.environment import OSType, detect_os_type
from mesh.utils.output import info, ok, section, warn

# Path to .env file (project root, one level up from mesh/)
ENV_PATH = Path(__file__).parents[4] / ".env"


def detect_platform() -> str:
    """Detect the current platform with more detail than OSType."""
    os_type = detect_os_type()
    machine = platform.machine().lower()

    # Map to human-readable names
    arch = (
        "arm64"
        if machine in ("aarch64", "arm64")
        else "x64"
        if machine in ("x86_64", "amd64")
        else machine
    )

    if os_type == OSType.WSL2:
        return f"WSL2 ({arch})"
    elif os_type == OSType.WINDOWS:
        return f"Windows ({arch})"
    elif os_type == OSType.UBUNTU:
        return f"Linux ({arch})"
    elif os_type == OSType.MACOS:
        return f"macOS ({arch})"
    else:
        return f"Unknown ({platform.system()} {arch})"


def get_hostname() -> str:
    """Get the current machine's hostname."""
    return socket.gethostname()


def read_existing_env() -> dict[str, str]:
    """Read existing .env file and return as dict."""
    if not ENV_PATH.exists():
        return {}

    config: dict[str, str] = {}
    for line in ENV_PATH.read_text().splitlines():
        line = line.strip()
        if line and not line.startswith("#") and "=" in line:
            key, _, value = line.partition("=")
            config[key.strip()] = value.strip()
    return config


def write_env_file(config: dict[str, str], dry_run: bool = False) -> None:
    """Write configuration to .env file.

    Args:
        config: Dictionary of environment variables to write.
        dry_run: If True, only show what would be written.
    """
    # Merge with existing config (new values override)
    existing = read_existing_env()
    merged = {**existing, **config}

    # Generate .env content
    lines = ["# Mesh network configuration", "# Generated by: mesh init", ""]
    for key, value in sorted(merged.items()):
        lines.append(f"{key}={value}")
    lines.append("")
    content = "\n".join(lines)

    if dry_run:
        section("Dry Run - Would Write to .env")
        for key, value in sorted(config.items()):
            # Mask sensitive values
            display_value = "***" if "key" in key.lower() else value
            info(f"  {key}={display_value}")
        return

    # Backup existing file
    if ENV_PATH.exists():
        backup_path = ENV_PATH.with_suffix(".env.backup")
        shutil.copy(ENV_PATH, backup_path)
        info(f"Backed up existing .env to {backup_path.name}")

    ENV_PATH.write_text(content)
    ok(f"Configuration written to {ENV_PATH}")


def prompt_server_config(hostname: str) -> dict[str, str]:
    """Gather server configuration via prompts."""
    config: dict[str, str] = {}

    # Server hostname
    config["MESH_SERVER_HOSTNAMES"] = Prompt.ask(
        "Server hostname(s)",
        default=hostname,
    )

    # Default user for SSH
    import os

    default_user = os.environ.get("USER", "ubuntu")
    config["MESH_DEFAULT_USER"] = Prompt.ask(
        "Default SSH user",
        default=default_user,
    )

    return config


def prompt_client_config(hostname: str, os_type: OSType) -> dict[str, str]:
    """Gather client configuration via prompts."""
    config: dict[str, str] = {}

    # Server URL - save to ~/.config/mesh/headscale-server for use by client commands
    server_url = Prompt.ask(
        "Headscale server URL",
        default="http://server.local:8080",
    )
    save_headscale_server(server_url)

    # Client hostname mapping based on OS type
    if os_type == OSType.WSL2:
        config["MESH_WSL2_HOSTNAMES"] = hostname
    elif os_type == OSType.WINDOWS:
        config["MESH_WINDOWS_HOSTNAMES"] = hostname
    else:
        # Generic Linux client - ask which role
        role = Prompt.ask(
            "Client type",
            choices=["linux", "wsl2", "windows"],
            default="linux",
        )
        if role == "wsl2":
            config["MESH_WSL2_HOSTNAMES"] = hostname
        elif role == "windows":
            config["MESH_WINDOWS_HOSTNAMES"] = hostname
        # For generic linux, no hostname mapping needed

    # Shared folder paths
    if Confirm.ask("Configure shared folder paths?", default=False):
        config["MESH_SHARED_FOLDER_LINUX"] = Prompt.ask(
            "Linux shared folder path",
            default="/home/shared",
        )
        config["MESH_SHARED_FOLDER_WINDOWS"] = Prompt.ask(
            "Windows shared folder path",
            default="C:\\Shared",
        )

    return config


def init(
    dry_run: bool = typer.Option(
        False, "--dry-run", "-n", help="Show what would be written without writing"
    ),
) -> None:
    """Interactive setup wizard for mesh network configuration.

    Detects your platform, asks for your role (server or client),
    and generates the appropriate .env configuration.
    """
    section("Mesh Network Setup Wizard")

    # Platform detection
    platform_str = detect_platform()
    hostname = get_hostname()
    os_type = detect_os_type()

    info(f"Platform: {platform_str}")
    info(f"Hostname: {hostname}")

    # Role selection
    role = Prompt.ask(
        "\nWhat is this machine's role?",
        choices=["server", "client"],
        default="client",
    )

    section(f"Configuring as {role.upper()}")

    # Gather role-specific configuration
    if role == "server":
        config = prompt_server_config(hostname)

        # Show next steps for server
        write_env_file(config, dry_run=dry_run)

        if not dry_run:
            section("Next Steps")
            info("1. Run: mesh server setup")
            info("   This installs and starts Headscale")
            info("")
            info("2. Generate a pre-auth key:")
            info("   mesh server keygen")
            info("")
            info("3. Share the key with clients for setup")
            if Confirm.ask("\nRun 'mesh server setup' now?", default=True):
                from mesh.commands.server import setup

                setup()

    else:
        config = prompt_client_config(hostname, os_type)

        write_env_file(config, dry_run=dry_run)

        if not dry_run:
            section("Next Steps")
            if os_type == OSType.WINDOWS:
                warn("Windows native install requires manual Tailscale/Syncthing setup")
                info("1. Install Tailscale: winget install tailscale.tailscale")
                info("2. Install Syncthing: winget install Syncthing.Syncthing")
                info("3. Run: mesh client setup --server <URL> --key <KEY>")
            else:
                info("Run: mesh client setup --server <URL> --key <KEY>")
                info("Or with auto-discovery: mesh client setup --discover --key <KEY>")
                info("")
                info("Get the key from your server admin")
